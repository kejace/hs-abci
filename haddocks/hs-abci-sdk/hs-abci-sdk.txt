-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/f-o-a-m/hs-abci/hs-abci-sdk#readme</a>
@package hs-abci-sdk
@version 0.1.0.0

module Proto.Modules.Auth

-- | Fields :
--   
--   <ul>
--   <li><a>coins</a> <tt>:: Lens' Account [Coin]</tt></li>
--   <li><a>vec'coins</a> <tt>:: Lens' Account (Data.Vector.Vector
--   Coin)</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' Account Data.Word.Word64</tt></li>
--   </ul>
data Account

-- | Fields :
--   
--   <ul>
--   <li><a>denomination</a> <tt>:: Lens' Coin Data.Text.Text</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Coin Data.Word.Word64</tt></li>
--   </ul>
data Coin
instance GHC.Classes.Ord Proto.Modules.Auth.Account
instance GHC.Classes.Eq Proto.Modules.Auth.Account
instance GHC.Classes.Ord Proto.Modules.Auth.Coin
instance GHC.Classes.Eq Proto.Modules.Auth.Coin
instance GHC.Show.Show Proto.Modules.Auth.Account
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "coins" [Proto.Modules.Auth.Coin]
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "vec'coins" (Data.Vector.Vector Proto.Modules.Auth.Coin)
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Account
instance Control.DeepSeq.NFData Proto.Modules.Auth.Account
instance GHC.Show.Show Proto.Modules.Auth.Coin
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "denomination" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Coin
instance Control.DeepSeq.NFData Proto.Modules.Auth.Coin

module Proto.Modules.Auth_Fields
amount :: forall f s a. (Functor f, HasField s "amount" a) => LensLike' f s a
coins :: forall f s a. (Functor f, HasField s "coins" a) => LensLike' f s a
denomination :: forall f s a. (Functor f, HasField s "denomination" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
vec'coins :: forall f s a. (Functor f, HasField s "vec'coins" a) => LensLike' f s a

module Proto.Types.Transaction

-- | Fields :
--   
--   <ul>
--   <li><a>data'</a> <tt>:: Lens' RawTransaction TypedMessage</tt></li>
--   <li><a>maybe'data'</a> <tt>:: Lens' RawTransaction (Prelude.Maybe
--   TypedMessage)</tt></li>
--   <li><a>gas</a> <tt>:: Lens' RawTransaction Data.Int.Int64</tt></li>
--   <li><a>signature</a> <tt>:: Lens' RawTransaction
--   Data.ByteString.ByteString</tt></li>
--   <li><a>route</a> <tt>:: Lens' RawTransaction Data.Text.Text</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' RawTransaction
--   Data.Word.Word64</tt></li>
--   </ul>
data RawTransaction

-- | Fields :
--   
--   <ul>
--   <li><a>type'</a> <tt>:: Lens' TypedMessage Data.Text.Text</tt></li>
--   <li><a>data'</a> <tt>:: Lens' TypedMessage
--   Data.ByteString.ByteString</tt></li>
--   </ul>
data TypedMessage
instance GHC.Classes.Ord Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Eq Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Ord Proto.Types.Transaction.TypedMessage
instance GHC.Classes.Eq Proto.Types.Transaction.TypedMessage
instance GHC.Show.Show Proto.Types.Transaction.RawTransaction
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "data'" Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "maybe'data'" (GHC.Maybe.Maybe Proto.Types.Transaction.TypedMessage)
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "gas" GHC.Int.Int64
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "signature" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "route" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.RawTransaction
instance Control.DeepSeq.NFData Proto.Types.Transaction.RawTransaction
instance GHC.Show.Show Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "type'" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "data'" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.TypedMessage
instance Control.DeepSeq.NFData Proto.Types.Transaction.TypedMessage

module Proto.Types.Transaction_Fields
data' :: forall f s a. (Functor f, HasField s "data'" a) => LensLike' f s a
gas :: forall f s a. (Functor f, HasField s "gas" a) => LensLike' f s a
maybe'data' :: forall f s a. (Functor f, HasField s "maybe'data'" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
route :: forall f s a. (Functor f, HasField s "route" a) => LensLike' f s a
signature :: forall f s a. (Functor f, HasField s "signature" a) => LensLike' f s a
type' :: forall f s a. (Functor f, HasField s "type'" a) => LensLike' f s a

module Tendermint.SDK.BaseApp.Logger

-- | Effect allowing for console logging.
data Logger m a
[Log] :: Severity -> Text -> Logger m ()
[AddContext] :: (Select x, ToJSON x) => x -> m a -> Logger m a
log :: forall r_azl3. MemberWithError Logger r_azl3 => Severity -> Text -> Sem r_azl3 ()
addContext :: forall r_azl6 x_XxZ2 a_axZ3. (MemberWithError Logger r_azl6, Select x_XxZ2, ToJSON x_XxZ2) => x_XxZ2 -> Sem r_azl6 a_axZ3 -> Sem r_azl6 a_axZ3
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Logger.Severity
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Logger.Severity

module Tendermint.SDK.BaseApp.Events
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
makeEventType :: ToEvent e => Proxy e -> String
makeEventData :: ToEvent e => e -> [(ByteString, ByteString)]
makeEventData :: (ToEvent e, ToJSON e) => e -> [(ByteString, ByteString)]

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
makeEvent :: ToEvent e => e -> Event
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Events.ToEvent a) => Data.Aeson.Types.ToJSON.ToJSON (Tendermint.SDK.BaseApp.Events.ContextEvent a)
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Events.ContextEvent a)

module Tendermint.SDK.BaseApp.Logger.Katip
data LogConfig
LogConfig :: Namespace -> LogContexts -> LogEnv -> LogConfig
[_logNamespace] :: LogConfig -> Namespace
[_logContext] :: LogConfig -> LogContexts
[_logEnv] :: LogConfig -> LogEnv
logNamespace :: Lens' LogConfig Namespace
logContext :: Lens' LogConfig LogContexts
logEnv :: Lens' LogConfig LogEnv
data InitialLogNamespace
InitialLogNamespace :: Text -> Text -> InitialLogNamespace
[_initialLogEnvironment] :: InitialLogNamespace -> Text
[_initialLogProcessName] :: InitialLogNamespace -> Text
initialLogEnvironment :: Lens' InitialLogNamespace Text
initialLogProcessName :: Lens' InitialLogNamespace Text
evalKatip :: forall r a. KatipContext (Sem r) => Sem (Logger : r) a -> Sem r a
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Katip.Core.ToObject (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Logger.Select a) => Katip.Core.LogItem (Tendermint.SDK.BaseApp.Logger.Katip.Object a)

module Tendermint.SDK.BaseApp.Metrics
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
data Metrics m a

-- | Increments the count of a specific message
[IncCount] :: CountName -> Metrics m ()

-- | Times an action and records it in a histogram
[WithTimer] :: HistogramName -> m a -> Metrics m a
withTimer :: forall r_aMVJ a_aMKv. MemberWithError Metrics r_aMVJ => HistogramName -> Sem r_aMVJ a_aMKv -> Sem r_aMVJ a_aMKv
incCount :: forall r_aMVH. MemberWithError Metrics r_aMVH => CountName -> Sem r_aMVH ()
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.CountName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.CountName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.HistogramName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.CountName

module Tendermint.SDK.BaseApp.Metrics.Prometheus

-- | Core metrics config
data MetricsScrapingConfig
MetricsScrapingConfig :: Int -> MetricsScrapingConfig
[_prometheusPort] :: MetricsScrapingConfig -> Int
prometheusPort :: Iso' MetricsScrapingConfig Int
data MetricsState
MetricsState :: Registry -> MVar (MetricsMap Counter) -> MVar (MetricsMap Histogram) -> MetricsState
[_metricsRegistry] :: MetricsState -> Registry
[_metricsCounters] :: MetricsState -> MVar (MetricsMap Counter)
[_metricsHistograms] :: MetricsState -> MVar (MetricsMap Histogram)
metricsRegistry :: Lens' MetricsState Registry
metricsCounters :: Lens' MetricsState (MVar (MetricsMap Counter))
metricsHistograms :: Lens' MetricsState (MVar (MetricsMap Histogram))
data PrometheusEnv
PrometheusEnv :: MetricsState -> MetricsScrapingConfig -> PrometheusEnv
[_envMetricsState] :: PrometheusEnv -> MetricsState
[_envMetricsScrapingConfig] :: PrometheusEnv -> MetricsScrapingConfig
envMetricsState :: Lens' PrometheusEnv MetricsState
envMetricsScrapingConfig :: Lens' PrometheusEnv MetricsScrapingConfig
emptyState :: IO MetricsState
forkMetricsServer :: MonadIO m => PrometheusEnv -> m ThreadId

-- | Prometheus registry index key
mkPrometheusMetricId :: MetricIdentifier -> MetricId

-- | Index key for storing metrics
metricIdStorable :: MetricIdentifier -> (Text, Labels)
countToIdentifier :: CountName -> MetricIdentifier
histogramToIdentifier :: HistogramName -> MetricIdentifier
evalWithMetrics :: Member (Embed IO) r => Member (Reader (Maybe PrometheusEnv)) r => Sem (Metrics : r) a -> Sem r a
evalNothing :: Sem (Metrics : r) a -> Sem r a

-- | Increments existing count, if it doesn't exist, creates a new |
--   counter and increments it.
evalMetrics :: Member (Embed IO) r => MetricsState -> Sem (Metrics : r) a -> Sem r a
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.Prometheus.MetricIdentifier

module Tendermint.SDK.Codec

-- | This class is used as a codec for all items stored in | the database
--   as well as incoming transaction messages.
class HasCodec a
encode :: HasCodec a => a -> ByteString
decode :: HasCodec a => ByteString -> Either Text a
defaultSDKAesonOptions :: String -> Options
instance Tendermint.SDK.Codec.HasCodec ()

module Tendermint.SDK.Types.Address

-- | Used as a unique identifier for an account.
newtype Address
Address :: HexString -> Address
addressToBytes :: Address -> ByteString
addressFromBytes :: ByteString -> Address
pubKeyToAddress :: PubKey -> Address
instance Data.Aeson.Types.FromJSON.FromJSON Tendermint.SDK.Types.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSON Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Ord Tendermint.SDK.Types.Address.Address
instance GHC.Generics.Generic Tendermint.SDK.Types.Address.Address
instance GHC.Show.Show Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Eq Tendermint.SDK.Types.Address.Address

module Tendermint.SDK.Crypto

-- | Class encapsulating data which can hashed.
class MakeDigest a
makeDigest :: MakeDigest a => a -> Digest SHA256

-- | Defines the types and methods for the signature schema parameterized
--   by <tt>alg</tt>.
class SignatureSchema alg where {
    type family PubKey alg :: *;
    type family PrivateKey alg :: *;
    type family Signature alg :: *;
    type family Message alg :: *;
}
algorithm :: SignatureSchema alg => Proxy alg -> Text
sign :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> Signature alg
verify :: SignatureSchema alg => Proxy alg -> PubKey alg -> Signature alg -> Message alg -> Bool
makePubKey :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (PubKey alg)
makeSignature :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (Signature alg)
derivePubKey :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> PubKey alg
addressFromPubKey :: SignatureSchema alg => Proxy alg -> PubKey alg -> Address

-- | Class allowing for signing and recovering signatures for messages.
class SignatureSchema alg => RecoverableSignatureSchema alg where {
    type family RecoverableSignature alg :: *;
}
signRecoverableMessage :: RecoverableSignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> RecoverableSignature alg
recover :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> Message alg -> Maybe (PubKey alg)
serializeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> ByteString
makeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> ByteString -> Maybe (RecoverableSignature alg)
parsePubKey :: SignatureSchema alg => Proxy alg -> PubKey -> Either Text (PubKey alg)
data Secp256k1
instance Tendermint.SDK.Crypto.SignatureSchema Tendermint.SDK.Crypto.Secp256k1
instance Tendermint.SDK.Crypto.RecoverableSignatureSchema Tendermint.SDK.Crypto.Secp256k1

module Tendermint.SDK.Types.Effects

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&

module Tendermint.SDK.Types.Message

-- | The basic message format embedded in any transaction.
data Msg msg
Msg :: Address -> msg -> Text -> Msg msg
[msgAuthor] :: Msg msg -> Address
[msgData] :: Msg msg -> msg
[msgType] :: Msg msg -> Text
class HasMessageType msg
messageType :: HasMessageType msg => Proxy msg -> Text
data TypedMessage
TypedMessage :: ByteString -> Text -> TypedMessage
[typedMsgData] :: TypedMessage -> ByteString
[typedMsgType] :: TypedMessage -> Text

-- | This is a general error type, primarily accomodating protobuf messages
--   being parsed | by either the <a>proto3-wire</a> | or the
--   <a>proto-lens</a> libraries.
data MessageParseError

-- | A <a>WireTypeError</a> occurs when the type of the data in the
--   protobuf binary format does not match the type encountered by the
--   parser.
WireTypeError :: Text -> MessageParseError

-- | A <a>BinaryError</a> occurs when we can't successfully parse the
--   contents of the field.
BinaryError :: Text -> MessageParseError

-- | An <a>EmbeddedError</a> occurs when we encounter an error while
--   parsing an embedded message.
EmbeddedError :: Text -> Maybe MessageParseError -> MessageParseError

-- | Unknown or unstructured parsing error.
OtherParseError :: Text -> MessageParseError

-- | Useful for returning in error logs or console logging.
formatMessageParseError :: MessageParseError -> Text
coerceProto3Error :: ParseError -> MessageParseError
coerceProtoLensError :: String -> MessageParseError

-- | Used during message validation to indicate that although the message
--   has parsed | correctly, it fails certain sanity checks.
data MessageSemanticError

-- | Used to indicate that the message signer does not have the authority
--   to send | this message.
PermissionError :: Text -> MessageSemanticError

-- | Used to indicate that a field isn't valid, e.g. enforces non-negative
--   quantities | or nonempty lists.
InvalidFieldError :: Text -> MessageSemanticError
OtherSemanticError :: Text -> MessageSemanticError
formatMessageSemanticError :: MessageSemanticError -> Text
class ValidateMessage msg
validateMessage :: ValidateMessage msg => Msg msg -> Validation [MessageSemanticError] ()
nonEmptyCheck :: Eq a => Monoid a => Text -> a -> Validation [MessageSemanticError] ()
isAuthorCheck :: Text -> Msg msg -> (msg -> Address) -> Validation [MessageSemanticError] ()
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Message.TypedMessage
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Message.TypedMessage
instance GHC.Base.Functor Tendermint.SDK.Types.Message.Msg

module Tendermint.SDK.Types.Transaction
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64

-- | Raw transaction type coming in over the wire
data RawTransaction
RawTransaction :: TypedMessage -> Int64 -> Text -> ByteString -> Word64 -> RawTransaction

-- | the encoded message via protobuf encoding
[rawTransactionData] :: RawTransaction -> TypedMessage
[rawTransactionGas] :: RawTransaction -> Int64

-- | module name
[rawTransactionRoute] :: RawTransaction -> Text
[rawTransactionSignature] :: RawTransaction -> ByteString
[rawTransactionNonce] :: RawTransaction -> Word64
signRawTransaction :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> PrivateKey alg -> RawTransaction -> RecoverableSignature alg

-- | Attempt to parse a Bytestring into a <a>RawTransaction</a> then as a
--   <a>Tx</a> without | attempting to parse the underlying message. This
--   is done as a preprocessing | step to the router, allowing for failure
--   before the router is ever | reached.
parseTx :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> ByteString -> Either Text (Tx alg ByteString)
instance GHC.Generics.Generic Tendermint.SDK.Types.Transaction.RawTransaction
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Crypto.MakeDigest Tendermint.SDK.Types.Transaction.RawTransaction
instance forall k (alg :: k). GHC.Base.Functor (Tendermint.SDK.Types.Transaction.Tx alg)

module Tendermint.SDK.Types.TxResult

-- | This type represents a common transaction result for the CheckTx | and
--   DeliverTx abci-messages.
data TxResult
TxResult :: Base64String -> Text -> Int64 -> Int64 -> [Event] -> Word32 -> Text -> Text -> TxResult
[_txResultData] :: TxResult -> Base64String
[_txResultInfo] :: TxResult -> Text
[_txResultGasWanted] :: TxResult -> Int64
[_txResultGasUsed] :: TxResult -> Int64
[_txResultEvents] :: TxResult -> [Event]
[_txResultCode] :: TxResult -> Word32
[_txResultLog] :: TxResult -> Text
[_txResultCodespace] :: TxResult -> Text
txResultLog :: Lens' TxResult Text
txResultInfo :: Lens' TxResult Text
txResultGasWanted :: Lens' TxResult Int64
txResultGasUsed :: Lens' TxResult Int64
txResultEvents :: Lens' TxResult [Event]
txResultData :: Lens' TxResult Base64String
txResultCodespace :: Lens' TxResult Text
txResultCode :: Lens' TxResult Word32

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the CheckTx abci-message.
checkTxTxResult :: Iso' CheckTx TxResult

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the DeliverTx abci-message.
deliverTxTxResult :: Iso' DeliverTx TxResult
instance Data.Default.Class.Default Tendermint.SDK.Types.TxResult.TxResult
instance GHC.Show.Show Tendermint.SDK.Types.TxResult.TxResult

module Tendermint.SDK.BaseApp.Errors

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the query abci-message.
queryAppError :: Lens' Query AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the checkTx/deliverTx abci-message.
txResultAppError :: Lens' TxResult AppError

-- | These errors originate from the SDK itself. The "sdk" namespace is
--   reserved | for this error type and should not be used in modules or
--   applications.
data SDKError

-- | Something went wrong and we have no idea what.
InternalError :: SDKError

-- | Parsing errors for SDK specific types, e.g. <tt>RawTransaction</tt> or
--   <tt>Msg</tt>, etc.
ParseError :: Text -> SDKError

-- | The name of the route that failed to match.
UnmatchedRoute :: Text -> SDKError
OutOfGasException :: SDKError
MessageValidation :: [Text] -> SDKError
SignatureRecoveryError :: Text -> SDKError
NonceException :: Word64 -> Word64 -> SDKError

-- | As of right now it's not expected that one can recover from an
--   <a>SDKError</a>, | so we are throwing them as <a>AppError</a>s
--   directly.
throwSDKError :: Member (Error AppError) r => SDKError -> Sem r a
instance GHC.Show.Show Tendermint.SDK.BaseApp.Errors.AppError
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Errors.AppError
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Errors.SDKError
instance GHC.Exception.Type.Exception Tendermint.SDK.BaseApp.Errors.AppError

module Tendermint.SDK.BaseApp.Store.RawStore
data RawStore m a
[RawStorePut] :: StoreKey ns -> ByteString -> ByteString -> RawStore m ()
[RawStoreGet] :: StoreKey ns -> ByteString -> RawStore m (Maybe ByteString)
[RawStoreDelete] :: StoreKey ns -> ByteString -> RawStore m ()
[RawStoreProve] :: StoreKey ns -> ByteString -> RawStore m (Maybe ByteString)
[RawStoreRoot] :: RawStore m ByteString
[RawStoreBeginTransaction] :: RawStore m ()
[RawStoreRollback] :: RawStore m ()
[RawStoreCommit] :: RawStore m ()
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns = a | a -> ns k;
}
prefixWith :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefixWith :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
newtype StoreKey n
StoreKey :: ByteString -> StoreKey n
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [RawStore, Error AppError] r => StoreKey ns -> k -> Sem r (Maybe (Value k ns))
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member RawStore r => StoreKey ns -> k -> Value k ns -> Sem r ()
delete :: forall k ns r. IsKey k ns => Member RawStore r => StoreKey ns -> k -> Sem r ()
prove :: forall k ns r. IsKey k ns => Member RawStore r => StoreKey ns -> k -> Sem r (Maybe ByteString)
storeRoot :: Member RawStore r => Sem r ByteString
withTransaction :: forall r a. Members [RawStore, Resource, Error AppError] r => Sem r a -> Sem r a
withSandbox :: forall r a. Members [RawStore, Resource, Error AppError] r => Sem r a -> Sem r a
beginBlock :: Member RawStore r => Sem r ()
commitBlock :: Member RawStore r => Sem r ()
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.Types.Address.Address

module Tendermint.SDK.BaseApp.Store.Scope
data ConnectionScope
Query :: ConnectionScope
Mempool :: ConnectionScope
Consensus :: ConnectionScope
type family ApplyScope (s :: ConnectionScope) (es :: EffectRow) :: EffectRow
applyScope :: forall s r. forall a. Sem (RawStore : r) a -> Sem (Tagged s RawStore : r) a
class ResolveScope s r
resolveScope :: ResolveScope s r => Sem (Tagged s RawStore : r) a -> Sem r a
data MergeScopes m a
[MergeScopes] :: MergeScopes m ()
mergeScopes :: forall r_a1670. MemberWithError MergeScopes r_a1670 => Sem r_a1670 ()

module Tendermint.SDK.BaseApp.Store.AuthTreeStore
data AuthTreeState
AuthTreeState :: AuthTree  'Query -> AuthTree  'Mempool -> AuthTree  'Consensus -> AuthTreeState
[query] :: AuthTreeState -> AuthTree  'Query
[mempool] :: AuthTreeState -> AuthTree  'Mempool
[consensus] :: AuthTreeState -> AuthTree  'Consensus
class AuthTreeGetter (s :: ConnectionScope)
getAuthTree :: AuthTreeGetter s => Proxy s -> AuthTreeState -> AuthTree s
initAuthTreeState :: IO AuthTreeState
evalMergeScopes :: Members [Reader AuthTreeState, Embed IO] r => Sem (MergeScopes : r) a -> Sem r a
evalTagged :: forall (s :: ConnectionScope) r. Members [Reader AuthTreeState, Embed IO] r => AuthTreeGetter s => forall a. Sem (Tagged s RawStore : r) a -> Sem r a
instance Tendermint.SDK.BaseApp.Store.AuthTreeStore.AuthTreeGetter 'Tendermint.SDK.BaseApp.Store.Scope.Query
instance Tendermint.SDK.BaseApp.Store.AuthTreeStore.AuthTreeGetter 'Tendermint.SDK.BaseApp.Store.Scope.Mempool
instance Tendermint.SDK.BaseApp.Store.AuthTreeStore.AuthTreeGetter 'Tendermint.SDK.BaseApp.Store.Scope.Consensus
instance Crypto.Data.Auth.Tree.Class.MerkleHash Tendermint.SDK.BaseApp.Store.AuthTreeStore.AuthTreeHash

module Tendermint.SDK.BaseApp.Store

module Tendermint.SDK.BaseApp.CoreEff

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[MergeScopes, Reader LogConfig, Reader (Maybe PrometheusEnv), Reader AuthTreeState, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> AuthTreeState -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextAuthTree] :: Context -> AuthTreeState
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextAuthTree :: Lens' Context AuthTreeState
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a
instance (Polysemy.Internal.Members Tendermint.SDK.BaseApp.CoreEff.CoreEffs r, Tendermint.SDK.BaseApp.Store.AuthTreeStore.AuthTreeGetter s) => Tendermint.SDK.BaseApp.Store.Scope.ResolveScope s r
instance Polysemy.Internal.Members Tendermint.SDK.BaseApp.CoreEff.CoreEffs r => Katip.Core.Katip (Polysemy.Internal.Sem r)
instance Polysemy.Internal.Members Tendermint.SDK.BaseApp.CoreEff.CoreEffs r => Katip.Monadic.KatipContext (Polysemy.Internal.Sem r)

module Tendermint.SDK.BaseApp.Router.Types
type Application m req res = req -> m (RouteResult res)
data RouterError
PathNotFound :: RouterError
ResourceNotFound :: RouterError
InvalidRequest :: Text -> RouterError
InternalError :: Text -> RouterError
data RouteResult a
Fail :: RouterError -> RouteResult a
FailFatal :: RouterError -> RouteResult a
Route :: a -> RouteResult a
data RouteResultT m a
RouteResultT :: m (RouteResult a) -> RouteResultT m a
[runRouteResultT] :: RouteResultT m a -> m (RouteResult a)
class HasPath t
path :: HasPath t => Lens' t Text
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Show.Show Tendermint.SDK.BaseApp.Router.Types.RouterError
instance Control.Monad.Trans.Class.MonadTrans Tendermint.SDK.BaseApp.Router.Types.RouteResultT
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Applicative Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Base.Monad Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Router.Types.RouterError

module Tendermint.SDK.BaseApp.Router.Router
type Router env r req res = Router' env (Application (Sem r) req res)
data Router' env a
StaticRouter :: Map Text (Router' env a) -> [env -> a] -> Router' env a
CaptureRouter :: Router' (Text, env) a -> Router' env a
Choice :: Router' env a -> Router' env a -> Router' env a
runRouter :: HasPath req => Router env r req res -> env -> Application (Sem r) req res
pathRouter :: Text -> Router' env a -> Router' env a
leafRouter :: (env -> a) -> Router' env a
choice :: Router' env a -> Router' env a -> Router' env a

module Tendermint.SDK.BaseApp.Router.Delayed
data Delayed m env req a
runAction :: Delayed (Sem r) env req (Sem r a) -> env -> req -> (a -> RouteResult b) -> Sem r (RouteResult b)

-- | Fail with the option to recover.
delayedFail :: Monad m => RouterError -> DelayedM m req a
addBody :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
addCapture :: Monad m => Delayed m env req (a -> b) -> (captured -> DelayedM m req a) -> Delayed m (captured, env) req b
addParameter :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
emptyDelayed :: Monad m => RouteResult a -> Delayed m b req a

-- | Gain access to the incoming request.
withRequest :: Monad m => (req -> DelayedM m req a) -> DelayedM m req a
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader req (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.Delayed m env req)

module Tendermint.SDK.BaseApp.Transaction.Types
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
data EmptyTxServer
EmptyTxServer :: EmptyTxServer
type TransactionApplication m = RoutingTx ByteString -> m TxResult
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
type Return = Return'  'OnCheckUnit
data Return' (c :: OnCheck) a
data OnCheck
OnCheckEval :: OnCheck
OnCheckUnit :: OnCheck
data TypedMessage msg
data msg :~> a
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64
instance GHC.Show.Show Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx
instance Tendermint.SDK.BaseApp.Router.Types.HasPath (Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx msg)

module Tendermint.SDK.BaseApp.Transaction.Modifier
data OnCheck
OnCheckEval :: OnCheck
OnCheckUnit :: OnCheck
type family OnCheckReturn (ctx :: RouteContext) (oc :: OnCheck) a

module Tendermint.SDK.BaseApp.Transaction.Checker
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
instance (Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx a r, Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx b r) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (a Servant.API.Alternative.:<|> b) r
instance forall k rest (r :: Polysemy.Internal.Kind.EffectRow) (path :: k). Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx rest r => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (path Servant.API.Sub.:> rest) r
instance forall k (r :: [(* -> *) -> * -> *]) msg (a :: k). (Polysemy.Internal.Union.Member (Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError) r, Tendermint.SDK.Types.Message.ValidateMessage msg) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return a) r
instance Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r

module Tendermint.SDK.BaseApp.Query.Types
data Leaf (a :: *)
data QA (a :: *)
type QueryApplication m = Query -> m Query
data QueryRequest
QueryRequest :: Text -> Text -> Base64String -> Bool -> Int64 -> QueryRequest
[queryRequestPath] :: QueryRequest -> Text
[queryRequestParamString] :: QueryRequest -> Text
[queryRequestData] :: QueryRequest -> Base64String
[queryRequestProve] :: QueryRequest -> Bool
[queryRequestHeight] :: QueryRequest -> Int64
parseQueryRequest :: Query -> QueryRequest
data QueryArgs a
QueryArgs :: Bool -> a -> Int64 -> QueryArgs a
[queryArgsProve] :: QueryArgs a -> Bool
[queryArgsData] :: QueryArgs a -> a
[queryArgsHeight] :: QueryArgs a -> Int64
defaultQueryArgs :: QueryArgs ()
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64

-- | class representing objects which can be queried via the hs-abci query
--   message. | Here the <a>Name</a> is the leaf of the query url, e.g. if
--   you can access a token | balance of type <tt>Balance</tt> at
--   "token/balance", then 'Name Balance ~ "balance"'.
class HasCodec a => Queryable a where {
    type family Name a :: Symbol;
}

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class FromQueryData a
fromQueryData :: FromQueryData a => Base64String -> Either String a
fromQueryData :: (FromQueryData a, RawKey a) => Base64String -> Either String a
data EmptyQueryServer
EmptyQueryServer :: EmptyQueryServer
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryResult
instance GHC.Show.Show a => GHC.Show.Show (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryArgs
instance GHC.Show.Show Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance Tendermint.SDK.BaseApp.Query.Types.FromQueryData Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.BaseApp.Router.Types.HasPath Tendermint.SDK.BaseApp.Query.Types.QueryRequest

module Tendermint.SDK.BaseApp.Query.Router

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: *;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout r) -> Router env r QueryRequest Query
emptyQueryServer :: RouteQ EmptyQueryServer r
methodRouter :: HasCodec b => Delayed (Sem r) env req (Sem r (QueryResult b)) -> Router env r req Query
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter a r, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter b r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (a Servant.API.Alternative.:<|> b) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (path Servant.API.Sub.:> sublayout) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> sublayout) r
instance (Web.Internal.HttpApiData.FromHttpApiData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> sublayout) r
instance Tendermint.SDK.Codec.HasCodec a => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.Leaf a) r
instance (Tendermint.SDK.BaseApp.Query.Types.FromQueryData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.QA a Servant.API.Sub.:> sublayout) r
instance Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter Tendermint.SDK.BaseApp.Query.Types.EmptyQueryServer r

module Tendermint.SDK.BaseApp.Query.Store
data StoreLeaf a
class StoreQueryHandler a (ns :: Symbol) h
storeQueryHandler :: StoreQueryHandler a ns h => Proxy a -> StoreKey ns -> h
class StoreQueryHandlers (kvs :: [*]) (ns :: Symbol) r where {
    type family QueryApi kvs :: *;
}
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members '[Tendermint.SDK.BaseApp.Store.RawStore.RawStore, Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError] r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers '[(k, a)] ns r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers ((k', a') : as) ns r, Polysemy.Internal.Members '[Tendermint.SDK.BaseApp.Store.RawStore.RawStore, Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError] r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers ((k, a) : (k', a') : as) ns r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members '[Tendermint.SDK.BaseApp.Store.RawStore.RawStore, Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError] r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler a ns (Tendermint.SDK.BaseApp.Query.Types.QueryArgs k -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult a))
instance (Tendermint.SDK.BaseApp.Query.Types.Queryable a, GHC.TypeLits.KnownSymbol (Tendermint.SDK.BaseApp.Query.Types.Name a)) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Store.StoreLeaf a) r

module Tendermint.SDK.BaseApp.Query
serveQueryApplication :: HasQueryRouter layout r => Proxy layout -> Proxy r -> RouteQ layout r -> QueryApplication (Sem r)

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: *;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout r) -> Router env r QueryRequest Query
class StoreQueryHandlers (kvs :: [*]) (ns :: Symbol) r where {
    type family QueryApi kvs :: *;
}
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
emptyQueryServer :: RouteQ EmptyQueryServer r

module Tendermint.SDK.BaseApp.Gas
data GasMeter m a
[WithGas] :: forall m a. GasAmount -> m a -> GasMeter m a
newtype GasAmount
GasAmount :: Int64 -> GasAmount
[unGasAmount] :: GasAmount -> Int64
withGas :: forall r_a1kMG a_a1kCb. MemberWithError GasMeter r_a1kMG => GasAmount -> Sem r_a1kMG a_a1kCb -> Sem r_a1kMG a_a1kCb
eval :: Members [Error AppError, State GasAmount] r => Sem (GasMeter : r) a -> Sem r a
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Num.Num Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Show.Show Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Gas.GasAmount

module Tendermint.SDK.BaseApp.Transaction.Effect
type TxEffs = [Output Event, GasMeter, Error AppError]
data TransactionContext
TransactionContext :: IORef GasAmount -> TransactionContext
[gas] :: TransactionContext -> IORef GasAmount
newTransactionContext :: RoutingTx msg -> IO TransactionContext
eval :: forall r a. HasCodec a => Member (Embed IO) r => TransactionContext -> Sem (TxEffs :& r) a -> Sem r TxResult

module Tendermint.SDK.BaseApp.Transaction.Router
class HasTxRouter layout r (c :: RouteContext) where {
    type family RouteTx layout r c :: *;
}
routeTx :: HasTxRouter layout r c => Proxy layout -> Proxy r -> Proxy c -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout r c) -> Router env r (RoutingTx ByteString) TxResult
emptyTxServer :: RouteTx EmptyTxServer r c
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter a r c, Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter b r c) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (a Servant.API.Alternative.:<|> b) r c
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter sublayout r c, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (path Servant.API.Sub.:> sublayout) r c
instance (Tendermint.SDK.Types.Message.HasMessageType msg, Tendermint.SDK.Codec.HasCodec msg, Tendermint.SDK.Codec.HasCodec (Tendermint.SDK.BaseApp.Transaction.Modifier.OnCheckReturn c oc a), Polysemy.Internal.Union.Member (Polysemy.Embed.Type.Embed GHC.Types.IO) r) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return' oc a) r c
instance Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r c

module Tendermint.SDK.BaseApp.Transaction
serveTxApplication :: HasTxRouter layout r c => Proxy layout -> Proxy r -> Proxy (c :: RouteContext) -> RouteTx layout r c -> TransactionApplication (Sem r)
serveDefaultTxChecker :: HasTxRouter layout r  'CheckTx => DefaultCheckTx layout r => RouteTx layout r  'CheckTx ~ DefaultCheckTxT layout r => Proxy layout -> Proxy r -> TransactionApplication (Sem r)
class HasTxRouter layout r (c :: RouteContext) where {
    type family RouteTx layout r c :: *;
}
routeTx :: HasTxRouter layout r c => Proxy layout -> Proxy r -> Proxy c -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout r c) -> Router env r (RoutingTx ByteString) TxResult
emptyTxServer :: RouteTx EmptyTxServer r c
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type TxEffs = [Output Event, GasMeter, Error AppError]

module Tendermint.SDK.BaseApp.BaseApp

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <a>RawStore</a>, you must
--   scope | these effects before they can be interpreted.
type BaseAppEffs = [RawStore, Metrics, Logger, Resource, Error AppError]
type BaseApp r = BaseAppEffs :& r
type ScopedBaseApp (s :: ConnectionScope) r = ApplyScope s (BaseApp r)
data ScopedEff r a
[QueryScoped] :: Sem (ScopedBaseApp  'Query r) a -> ScopedEff r a
[MempoolScoped] :: Sem (ScopedBaseApp  'Mempool r) a -> ScopedEff r a
[ConsensusScoped] :: Sem (ScopedBaseApp  'Consensus r) a -> ScopedEff r a
compileScopedEff :: ScopedEff CoreEffs a -> Sem CoreEffs a

-- | An intermediary interpeter, bringing <a>BaseApp</a> down to
--   <tt>CoreEff</tt>.
compileToCoreEffs :: AuthTreeGetter s => forall a. Sem (ScopedBaseApp s CoreEffs) a -> Sem CoreEffs a

module Tendermint.SDK.BaseApp

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <a>RawStore</a>, you must
--   scope | these effects before they can be interpreted.
type BaseAppEffs = [RawStore, Metrics, Logger, Resource, Error AppError]

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&
type BaseApp r = BaseAppEffs :& r
type ScopedBaseApp (s :: ConnectionScope) r = ApplyScope s (BaseApp r)

-- | An intermediary interpeter, bringing <a>BaseApp</a> down to
--   <tt>CoreEff</tt>.
compileToCoreEffs :: AuthTreeGetter s => forall a. Sem (ScopedBaseApp s CoreEffs) a -> Sem CoreEffs a
compileScopedEff :: ScopedEff CoreEffs a -> Sem CoreEffs a

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[MergeScopes, Reader LogConfig, Reader (Maybe PrometheusEnv), Reader AuthTreeState, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> AuthTreeState -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextAuthTree] :: Context -> AuthTreeState
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextAuthTree :: Lens' Context AuthTreeState
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a
data RawStore m a
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns = a | a -> ns k;
}
prefixWith :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefixWith :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
newtype StoreKey n
StoreKey :: ByteString -> StoreKey n
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member RawStore r => StoreKey ns -> k -> Value k ns -> Sem r ()
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [RawStore, Error AppError] r => StoreKey ns -> k -> Sem r (Maybe (Value k ns))
delete :: forall k ns r. IsKey k ns => Member RawStore r => StoreKey ns -> k -> Sem r ()
data Leaf (a :: *)
data QA (a :: *)
data ConnectionScope
Query :: ConnectionScope
Mempool :: ConnectionScope
Consensus :: ConnectionScope
applyScope :: forall s r. forall a. Sem (RawStore : r) a -> Sem (Tagged s RawStore : r) a

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError

-- | These errors originate from the SDK itself. The "sdk" namespace is
--   reserved | for this error type and should not be used in modules or
--   applications.
data SDKError

-- | Something went wrong and we have no idea what.
InternalError :: SDKError

-- | Parsing errors for SDK specific types, e.g. <tt>RawTransaction</tt> or
--   <tt>Msg</tt>, etc.
ParseError :: Text -> SDKError

-- | The name of the route that failed to match.
UnmatchedRoute :: Text -> SDKError
OutOfGasException :: SDKError
MessageValidation :: [Text] -> SDKError
SignatureRecoveryError :: Text -> SDKError
NonceException :: Word64 -> Word64 -> SDKError

-- | As of right now it's not expected that one can recover from an
--   <a>SDKError</a>, | so we are throwing them as <a>AppError</a>s
--   directly.
throwSDKError :: Member (Error AppError) r => SDKError -> Sem r a
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
makeEventType :: ToEvent e => Proxy e -> String
makeEventData :: ToEvent e => e -> [(ByteString, ByteString)]
makeEventData :: (ToEvent e, ToJSON e) => e -> [(ByteString, ByteString)]

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
data GasMeter m a

-- | Effect allowing for console logging.
data Logger m a
log :: forall r_azl3. MemberWithError Logger r_azl3 => Severity -> Text -> Sem r_azl3 ()
addContext :: forall r_azl6 x_XxZ2 a_axZ3. (MemberWithError Logger r_azl6, Select x_XxZ2, ToJSON x_XxZ2) => x_XxZ2 -> Sem r_azl6 a_axZ3 -> Sem r_azl6 a_axZ3
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
data Metrics m a
incCount :: forall r_aMVH. MemberWithError Metrics r_aMVH => CountName -> Sem r_aMVH ()
withTimer :: forall r_aMVJ a_aMKv. MemberWithError Metrics r_aMVJ => HistogramName -> Sem r_aMVJ a_aMKv -> Sem r_aMVJ a_aMKv
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
type TransactionApplication m = RoutingTx ByteString -> m TxResult
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
type family RouteTx layout r c :: *
type Return = Return'  'OnCheckUnit
data msg :~> a
data TypedMessage msg
type TxEffs = [Output Event, GasMeter, Error AppError]
data EmptyTxServer
emptyTxServer :: RouteTx EmptyTxServer r c
serveTxApplication :: HasTxRouter layout r c => Proxy layout -> Proxy r -> Proxy (c :: RouteContext) -> RouteTx layout r c -> TransactionApplication (Sem r)
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r

-- | class representing objects which can be queried via the hs-abci query
--   message. | Here the <a>Name</a> is the leaf of the query url, e.g. if
--   you can access a token | balance of type <tt>Balance</tt> at
--   "token/balance", then 'Name Balance ~ "balance"'.
class HasCodec a => Queryable a where {
    type family Name a :: Symbol;
}

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class FromQueryData a
fromQueryData :: FromQueryData a => Base64String -> Either String a
fromQueryData :: (FromQueryData a, RawKey a) => Base64String -> Either String a
type family QueryApi kvs :: *

-- | A routeQ handler.
type family RouteQ layout r :: *
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
serveQueryApplication :: HasQueryRouter layout r => Proxy layout -> Proxy r -> RouteQ layout r -> QueryApplication (Sem r)
data EmptyQueryServer
emptyQueryServer :: RouteQ EmptyQueryServer r

module Tendermint.SDK.Application.Module
data Module (name :: Symbol) (h :: *) (q :: *) (s :: EffectRow) (r :: EffectRow)
Module :: RouteTx h r  'DeliverTx -> RouteTx h r  'CheckTx -> RouteQ q r -> (forall deps. Members BaseAppEffs deps => forall a. Sem (s :& deps) a -> Sem deps a) -> Module
[moduleTxDeliverer] :: Module -> RouteTx h r  'DeliverTx
[moduleTxChecker] :: Module -> RouteTx h r  'CheckTx
[moduleQueryServer] :: Module -> RouteQ q r
[moduleEval] :: Module -> forall deps. Members BaseAppEffs deps => forall a. Sem (s :& deps) a -> Sem deps a
data Modules (ms :: [*]) r
[NilModules] :: Modules '[] r
[:+] :: Module name h q s r -> Modules ms r -> Modules (Module name h q s r : ms) r
infixr 5 :+
class AppQueryRouter ms r where {
    type family QApi ms :: *;
}
routeAppQuery :: AppQueryRouter ms r => Modules ms r -> RouteQ (QApi ms) r
appQueryRouter :: AppQueryRouter ms r => HasQueryRouter (QApi ms) r => Modules ms r -> QueryApplication (Sem r)
class AppTxRouter ms r (c :: RouteContext) where {
    type family TApi ms :: *;
}
routeAppTx :: AppTxRouter ms r c => Proxy c -> Modules ms r -> RouteTx (TApi ms) r c
appTxRouter :: AppTxRouter ms r  'DeliverTx => AppTxRouter ms r  'CheckTx => HasTxRouter (TApi ms) r  'DeliverTx => HasTxRouter (TApi ms) r  'CheckTx => Modules ms r -> RouteContext -> TransactionApplication (Sem r)
class Eval ms core where {
    type family Effs ms core :: EffectRow;
}
eval :: Eval ms core => Modules ms r -> forall a. Sem (Effs ms core) a -> Sem (BaseApp core) a
instance Tendermint.SDK.Application.Module.Eval '[Tendermint.SDK.Application.Module.Module name h q s r] core
instance (Polysemy.Internal.Members Tendermint.SDK.BaseApp.BaseApp.BaseAppEffs (Tendermint.SDK.Application.Module.Effs (m' : ms) core), Tendermint.SDK.Application.Module.Eval (m' : ms) core) => Tendermint.SDK.Application.Module.Eval (Tendermint.SDK.Application.Module.Module name h q s r : m' : ms) core
instance Tendermint.SDK.Application.Module.AppTxRouter '[Tendermint.SDK.Application.Module.Module name h q s r] r 'Tendermint.SDK.BaseApp.Transaction.Types.CheckTx
instance Tendermint.SDK.Application.Module.AppTxRouter (m' : ms) r 'Tendermint.SDK.BaseApp.Transaction.Types.CheckTx => Tendermint.SDK.Application.Module.AppTxRouter (Tendermint.SDK.Application.Module.Module name h q s r : m' : ms) r 'Tendermint.SDK.BaseApp.Transaction.Types.CheckTx
instance Tendermint.SDK.Application.Module.AppTxRouter '[Tendermint.SDK.Application.Module.Module name h q s r] r 'Tendermint.SDK.BaseApp.Transaction.Types.DeliverTx
instance Tendermint.SDK.Application.Module.AppTxRouter (m' : ms) r 'Tendermint.SDK.BaseApp.Transaction.Types.DeliverTx => Tendermint.SDK.Application.Module.AppTxRouter (Tendermint.SDK.Application.Module.Module name h q s r : m' : ms) r 'Tendermint.SDK.BaseApp.Transaction.Types.DeliverTx
instance Tendermint.SDK.Application.Module.AppQueryRouter '[Tendermint.SDK.Application.Module.Module name h q s r] r
instance Tendermint.SDK.Application.Module.AppQueryRouter (m' : ms) r => Tendermint.SDK.Application.Module.AppQueryRouter (Tendermint.SDK.Application.Module.Module name h q s r : m' : ms) r

module Tendermint.SDK.Modules.Auth
type AuthM r = Module AuthModule EmptyTxServer Api AuthEffs r
authModule :: Members BaseAppEffs r => AuthM r
type AuthEffs = '[Accounts, Error AuthError]
data Account
Account :: [Coin] -> Word64 -> Account
[accountCoins] :: Account -> [Coin]
[accountNonce] :: Account -> Word64
data Accounts m a
[PutAccount] :: Address -> Account -> Accounts m ()
[GetAccount] :: Address -> Accounts m (Maybe Account)
getAccount :: forall r_a1oYI. MemberWithError Accounts r_a1oYI => Address -> Sem r_a1oYI (Maybe Account)
putAccount :: forall r_a1oYF. MemberWithError Accounts r_a1oYF => Address -> Account -> Sem r_a1oYF ()
createAccount :: Members [Accounts, Error AuthError] r => Address -> Sem r Account
eval :: Members [RawStore, Error AppError] r => Sem (Accounts : (Error AuthError : r)) a -> Sem r a
type Api = QueryApi AuthContents
server :: Members [RawStore, Error AppError] r => RouteQ Api r
type AuthModule = "auth"
data Coin
Coin :: Text -> Word64 -> Coin
[coinDenomination] :: Coin -> Text
[coinAmount] :: Coin -> Word64
data Account
Account :: [Coin] -> Word64 -> Account
[accountCoins] :: Account -> [Coin]
[accountNonce] :: Account -> Word64
data AuthError
AccountAlreadExists :: Address -> AuthError

module Tendermint.SDK.Application.App
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO

module Tendermint.SDK.Application.AnteHandler
data AnteHandler r
AnteHandler :: (TransactionApplication (Sem r) -> TransactionApplication (Sem r)) -> AnteHandler r
applyAnteHandler :: AnteHandler r -> TransactionApplication (Sem r) -> TransactionApplication (Sem r)
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
instance GHC.Base.Semigroup (Tendermint.SDK.Application.AnteHandler.AnteHandler r)
instance GHC.Base.Monoid (Tendermint.SDK.Application.AnteHandler.AnteHandler r)

module Tendermint.SDK.Application.Handlers
type Handler mt r = Request mt -> Sem r (Response mt)
data HandlersContext alg ms r core
HandlersContext :: Proxy alg -> Modules ms r -> (forall a. ScopedEff core a -> Sem core a) -> AnteHandler r -> HandlersContext alg ms r core
[signatureAlgP] :: HandlersContext alg ms r core -> Proxy alg
[modules] :: HandlersContext alg ms r core -> Modules ms r
[compileToCore] :: HandlersContext alg ms r core -> forall a. ScopedEff core a -> Sem core a
[anteHandler] :: HandlersContext alg ms r core -> AnteHandler r
makeApp :: forall alg ms r core. Members [Error AppError, Embed IO] r => RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => AppTxRouter ms r  'DeliverTx => AppTxRouter ms r  'CheckTx => AppQueryRouter ms r => HasQueryRouter (QApi ms) r => HasTxRouter (TApi ms) r  'DeliverTx => HasTxRouter (TApi ms) r  'CheckTx => Members CoreEffs core => Eval ms core => Effs ms core ~ r => HandlersContext alg ms r core -> App (Sem core)

module Tendermint.SDK.Application
data Modules (ms :: [*]) r
[NilModules] :: Modules '[] r
[:+] :: Module name h q s r -> Modules ms r -> Modules (Module name h q s r : ms) r
infixr 5 :+
data Module (name :: Symbol) (h :: *) (q :: *) (s :: EffectRow) (r :: EffectRow)
Module :: RouteTx h r  'DeliverTx -> RouteTx h r  'CheckTx -> RouteQ q r -> (forall deps. Members BaseAppEffs deps => forall a. Sem (s :& deps) a -> Sem deps a) -> Module
[moduleTxDeliverer] :: Module -> RouteTx h r  'DeliverTx
[moduleTxChecker] :: Module -> RouteTx h r  'CheckTx
[moduleQueryServer] :: Module -> RouteQ q r
[moduleEval] :: Module -> forall deps. Members BaseAppEffs deps => forall a. Sem (s :& deps) a -> Sem deps a
data HandlersContext alg ms r core
HandlersContext :: Proxy alg -> Modules ms r -> (forall a. ScopedEff core a -> Sem core a) -> AnteHandler r -> HandlersContext alg ms r core
[signatureAlgP] :: HandlersContext alg ms r core -> Proxy alg
[modules] :: HandlersContext alg ms r core -> Modules ms r
[compileToCore] :: HandlersContext alg ms r core -> forall a. ScopedEff core a -> Sem core a
[anteHandler] :: HandlersContext alg ms r core -> AnteHandler r
data AnteHandler r
AnteHandler :: (TransactionApplication (Sem r) -> TransactionApplication (Sem r)) -> AnteHandler r
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO
makeApp :: forall alg ms r core. Members [Error AppError, Embed IO] r => RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => AppTxRouter ms r  'DeliverTx => AppTxRouter ms r  'CheckTx => AppQueryRouter ms r => HasQueryRouter (QApi ms) r => HasTxRouter (TApi ms) r  'DeliverTx => HasTxRouter (TApi ms) r  'CheckTx => Members CoreEffs core => Eval ms core => Effs ms core ~ r => HandlersContext alg ms r core -> App (Sem core)
