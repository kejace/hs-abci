<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Nameservice - Types - </title> <link rel="shortcut icon" href="/hs-abci/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/hs-abci/assets/css/just-the-docs.css"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-5555555-55"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', "UA-5555555-55"); </script> <script type="text/javascript" src="/hs-abci/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/hs-abci/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Nameservice - Types</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Nameservice - Types" /> <meta property="og:locale" content="en_US" /> <script type="application/ld+json"> {"headline":"Nameservice - Types","@type":"WebPage","url":"/hs-abci/tutorial/Tutorial/Nameservice/Types.lhs","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="link" viewBox="0 0 16 16"> <title>Link</title> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path> </symbol> </svg> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="hs-abci" class="site-title lh-tight"> </a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Application.html" class="navigation-list-link">Nameservice - Application</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/BaseApp.html" class="navigation-list-link">Foundations - BaseApp</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Keeper.html" class="navigation-list-link">Nameservice - Keeper</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Message.html" class="navigation-list-link">Nameservice - Message</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Module.html" class="navigation-list-link">Nameservice - Module</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/Modules.html" class="navigation-list-link">Foundations - Modules</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/Overview.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Overview.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Query.html" class="navigation-list-link">Nameservice - Query</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/README.html" class="navigation-list-link">Tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Types.html" class="navigation-list-link">Nameservice - Types</a></li><li class="navigation-list-item active"><a href="/hs-abci/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/" class="navigation-list-link">Tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/" class="navigation-list-link">hs-abci</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/f-o-a-m/hs-abci">GitHub project</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h# Types The `Types` module is used to define the basic types that the module will make use of. This includes things like custom error types, event types, database types, etc. ## Using A Typed Key Value Store It is important to note that the database modeled by the `RawStore` effect (in the `BaseApp` type) is just a key value store for raw `ByteString`s. This means you can _think_ of `RawStore` as ```haskell type RawStore = Map ByteString ByteString ``` although the definition of `RawStore` is different than the above. The interface we give is actually a typed key value store. This means that within the scope of a module `m`, for any key type `k`, there is only one possible value type `v` associated with `k`. For example, a user's balance in the `Token` module, might be modeled by a mapping ```haskell balance :: Tendermint.SDK.Types.Address -> Integer ``` (We'll properly introduce the module `Token` later in the walkthrough.) This means that in the scope of the `Token` module, the database utlity `get` function applied to a value of type `Address` will result in a value of type `Integer`. If the `Token` module would like to store another mapping whose keys have type `Tendermint.SDK.Types.Address`, you must use a newtype instead. Otherwise you will get a compiler error. At the same time, you are free to define another mapping from `k -> v'` in the scope of a different module. For example, you can have both the `balance` mapping described above, as well a mapping ```haskell owner :: Tendermint.SDK.Types.Address -> Account ``` in the `Auth` module. ## Tutorial.Nameservice.Types Let's look at the example in `Nameservice.Types`. ```haskell module Tutorial.Nameservice.Types where import Control.Lens (iso) import qualified Data.Aeson as A import Data.Bifunctor (first) import Data.Proxy import Data.String.Conversions (cs) import Data.Text (Text) import GHC.Generics (Generic) import GHC.TypeLits (symbolVal) import Nameservice.Aeson (defaultNameserviceOptions) import Nameservice.Modules.Token (Amount) import Proto3.Suite (Message, fromByteString, toLazyByteString) import qualified Tendermint.SDK.BaseApp as BA import Tendermint.SDK.Codec (HasCodec(..)) import Tendermint.SDK.Types.Address (Address) import Tendermint.SDK.Types.Message (coerceProto3Error, formatMessageParseError) ``` ### Storage types Remember the `Nameservice` module is responsible for maintaining a marketplace around a mapping `Name -> Whois`. Let us define the types for the marketplace mapping as ```haskell newtype Name = Name Text deriving (Eq, Show, Generic, A.ToJSON, A.FromJSON) data Whois = Whois { whoisValue :: Text , whoisOwner :: Address , whoisPrice :: Amount } deriving (Eq, Show, Generic) ``` The way that we register `Name` as a key in the store is by using the `RawKey` typeclass ```haskell class RawKey k where rawKey :: Iso' k ByteString ``` This class gives us a way to convert back and forth from a key to its encoding as a `ByteString`. In our case we implement ```haskell -- here cs resolves to Data.Text.Encoding.encodeUtf8, Data.Text.Encoding.decodeUtf8 respectively instance BA.RawKey Name where rawKey = iso (\(Name n) -> cs n) (Name . cs) ``` In order to register `Whois` as a storage type, we must implement the `HasCodec` typeclass ```haskell class HasCodec a where encode :: a -> ByteString decode :: ByteString -> Either Text a ``` This class is used everywhere in the SDK as the binary codec class for things like storage items, messages, transaction formats etc. It's agnostic to the actual serialization format, you can use `JSON`, `CBOR`, `Protobuf`, etc. Throughout the SDK we typically use `protobuf` as it is powerful in addition to the fact that there's decent support for this in Haskell either through the `proto3-suite` package or the `proto-lens` package. So we can implement a `HasCodec` instance for `Whois` ```haskell -- Message is a class from proto3-suite that defines protobuf codecs generically. instance Message Whois instance HasCodec Whois where encode = cs . toLazyByteString decode = first (formatMessageParseError . coerceProto3Error) . fromByteString ``` Finally we can register `(Name, Whois)` with the module's store with the `IsKey` class, which tells how to associate a key type with a value type within the scope of given module, where the scope is represented by the modules name as a type level string. There is an optional prefixing function for the key in this context in order to avoid collisions in the database. This would be useful for example if you were using multiple newtyped `Address` types as keys in the same module. ```haskell class RawKey k => IsKey k ns where type Value k ns = a | a -> ns k prefixWith :: Proxy k -> Proxy ns -> BS.ByteString default prefixWith :: Proxy k -> Proxy ns -> BS.ByteString prefixWith _ _ = "" ``` For the case of the `Name -> Whois` mapping, the `IsKey` instance looked like looks like this: ```haskell type NameserviceModuleName = "nameservice" instance BA.IsKey Name NameserviceModuleName where type Value Name NameserviceModuleName = Whois ``` At is point, you can use the database operations exported by `Tendermint.SDK.BaseApp.Store` such as `put`/`set`/`delete` for key value pairs of type `(Name, Whois)`. ### Query Types The [`cosmos-sdk`](https://github.com/cosmos/cosmos-sdk) assumes that you use `url` formatted queries with some possible query params. For example, to query a `Whois` value based on a `Name`, you might submit a `query` message with the route `nameservice/whois` and supply a value of type `Name` to specify as the `data` field. Our SDK makes the same assumption for compatability reasons. In order to register the `Whois` type with the query service, you must implement the `Queryable` typeclass: ```haskell class Queryable a where type Name a :: Symbol encodeQueryResult :: a -> Base64String decodeQueryResult :: Base64String -> Either Text a default encodeQueryResult :: HasCodec a => a -> Base64String encodeQueryResult = fromBytes . encode default decodeQueryResult :: HasCodec a => Base64String -> Either Text a decodeQueryResult = decode . toByte ``` What this means is that you need to supply codecs for the type to query, with the default using the `HasCodec` class. You also need to name the type, as this will match the leaf of the `url` used for querying. So for example, in the Nameservice app we have ```haskell instance BA.Queryable Whois where type Name Whois = "whois" ``` since `Whois` already implements the `HasCodec` class. ### Error Types You might want to define a module specific error type that has a `throw`/`catch` interface. This error type should be accessible by any other dependent modules, and any uncaught error should eventually be converted into some kind of generic application error understandable by Tendermint. There is a simple way to do this using the `IsAppError` typeclass ```haskell data AppError = AppError { appErrorCode :: Word32 , appErrorCodespace :: Text , appErrorMessage :: Text } deriving Show class IsAppError e where makeAppError :: e -> AppError ``` The fields for `AppError` correspond to tendermint message fields for messages that support error return types, such as `checkTx`, `deliverTx`, and `query`. Typically we use the module name as the codespace, like in the definition of `NamespaceError`: ```haskell data NameserviceError = InsufficientBid Text | UnauthorizedSet Text | InvalidDelete Text instance BA.IsAppError NameserviceError where -- remember 'symbolVal (Proxy @NameserviceModuleName)' resolves to "nameservice" makeAppError (InsufficientBid msg) = BA.AppError { appErrorCode = 1 , appErrorCodespace = cs $ symbolVal (Proxy @NameserviceModuleName) , appErrorMessage = msg } makeAppError (UnauthorizedSet msg) = BA.AppError { appErrorCode = 2 , appErrorCodespace = cs $ symbolVal (Proxy @NameserviceModuleName) , appErrorMessage = msg } makeAppError (InvalidDelete msg) = BA.AppError { appErrorCode = 3 , appErrorCodespace = cs $ symbolVal (Proxy @NameserviceModuleName) , appErrorMessage = msg } ``` ### Event Types Tendermint has the capability to report event logs for transactions in the responses for both `checkTx` and `deliverTx` messages. The basic event type can be found in `Network.ABCI.Types.MessageFields`, it is simply a named key value mapping between `Bytestring`s: ```haskell data Event = Event { eventType :: Text -- ^ Type of Event , eventAttributes :: [KVPair] -- ^ Event attributes } data KVPair = KVPair { kVPairKey :: Base64String -- ^ key , kVPairValue :: Base64String -- ^ value } ``` Similar to the custom error messages, you can define custom events at the module level as long as they implement the `ToEvent` class to translate them to this standard type: ```haskell class ToEvent e where makeEventType :: Proxy e -> String makeEventData :: e -> [(BS.ByteString, BS.ByteString)] default makeEventData :: A.ToJSON e => e -> [(BS.ByteString, BS.ByteString)] makeEventData e = case A.toJSON e of A.Object obj -> bimap cs (cs . A.encode) <$> toList obj _ -> mempty ``` As you can see, there is a default instance for those types which have a `JSON` representation as an `Object`. The reason that we chose a `JSON` default instance is simply because of support for generics, but this isn't set in stone. In the case of `Nameservice`, here is an example of a custom event: ```haskell data NameClaimed = NameClaimed { nameClaimedOwner :: Address , nameClaimedName :: Name , nameClaimedValue :: Text , nameClaimedBid :: Amount } deriving (Eq, Show, Generic) -- 'defaultNameserviceOptions' is used to remove the record accessor prefix. nameClaimedAesonOptions :: A.Options nameClaimedAesonOptions = defaultNameserviceOptions "nameClaimed" instance A.ToJSON NameClaimed where toJSON = A.genericToJSON nameClaimedAesonOptions instance A.FromJSON NameClaimed where parseJSON = A.genericParseJSON nameClaimedAesonOptions instance BA.ToEvent NameClaimed where makeEventType _ = "NameClaimed" ``` [Next: Message](Message.md) </div> </div> </div> </div> </body> </html>
