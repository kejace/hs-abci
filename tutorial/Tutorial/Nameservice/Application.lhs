<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>tutorial - </title> <link rel="shortcut icon" href="/hs-abci/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/hs-abci/assets/css/just-the-docs.css"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-5555555-55"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', "UA-5555555-55"); </script> <script type="text/javascript" src="/hs-abci/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/hs-abci/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>tutorial</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="tutorial" /> <meta property="og:locale" content="en_US" /> <script type="application/ld+json"> {"headline":"tutorial","@type":"WebPage","url":"/hs-abci/tutorial/Tutorial/Nameservice/Application.lhs","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="link" viewBox="0 0 16 16"> <title>Link</title> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path> </symbol> </svg> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="hs-abci" class="site-title lh-tight"> </a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Application.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/BaseApp.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Keeper.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Message.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Module.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/Modules.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Foundations/Overview.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Overview.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Query.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/README.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/Tutorial/Nameservice/Types.html" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item active"><a href="/hs-abci/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="/hs-abci/tutorial/" class="navigation-list-link">tutorial</a></li><li class="navigation-list-item"><a href="/hs-abci/" class="navigation-list-link">hs-abci</a></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="//github.com/f-o-a-m/hs-abci">GitHub project</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <h# Application ## From Modules to App The `App` type in `Network.ABCI.Server` is defined as ```haskell newtype App m = App { unApp :: forall (t :: MessageType). Request t -> m (Response t) } ``` and ultimately our configuration of modules must be converted to this format. This is probably the most important part of the SDK, to provide the bridge between the list of modules - a heterogeneous list of type `Modules` - and the actual application. The type that provides the input for this bridge is `HandlersContext`: ```haskell data HandlersContext alg ms r core = HandlersContext { signatureAlgP :: Proxy alg , modules :: M.Modules ms r , compileToCore :: forall a. ScopedEff core a -> Sem core a } ``` where - `alg` is the signature schema you would like to use for authentication (e.g. Secp256k1) - `ms` is the type level list of modules - `r` is the global effects list for the application - `core` is the set of core effects that are used to interpet `BaseApp` to `IO`. We should say a few words on this `compileToCore` field. The application developer has access to any effects in `BaseApp`, but `BaseApp` itself still needs to be interpreted in order to run the application. In other words, `BaseApp` is still just a list of free effects. The set of effects capable of interpreting `BaseApp` is called `core`, and while the developer is free to provide any `core` they want, we have a standard set of them in the SDK - e.g. in memory, production, etc. The `ScopedEff` type is more complicated and not relevant to the discussion of application development. Long story short, tendermint core requests three connections to the application's state - `Consensus`, `Mempool` and `Query`. The `ScopedEff` type is used to abstract this concern away from the developer, and as long as you are using one of the `core` effects provided in the SDK you don't need to worry about it. ## Tutorial.Nameservice.Application ```haskell module Tutorial.Nameservice.Application where import Data.Proxy import Nameservice.Modules.Nameservice (nameserviceModule, NameserviceM, NameserviceEffs) import Nameservice.Modules.Token (tokenModule, TokenM, TokenEffs) import Network.ABCI.Server.App (App) import Polysemy (Sem) import Tendermint.SDK.Modules.Auth (authModule, AuthEffs, AuthM) import Tendermint.SDK.Application (Modules(..), HandlersContext(..), baseAppAnteHandler, makeApp) import Tendermint.SDK.BaseApp (BaseApp, CoreEffs, (:&), compileScopedEff) import Tendermint.SDK.Crypto (Secp256k1) ``` This is the part of the application where the effects list must be given a monomorphic type. There is also a requirement that the `Modules` type for the application be given the same _order_ as the effects introducted. This ordering problem is due to the fact that type level lists are used to represent the effects in `polysemy`, and the order matters there. Still, it's only a small annoyance. ```haskell type EffR = NameserviceEffs :& TokenEffs :& AuthEffs :& BaseApp CoreEffs type NameserviceModules = '[ NameserviceM EffR , TokenM EffR , AuthM EffR ] ``` Notice that we've specified `EffR` as the effects list for each of the modules to run in, which trivially satisfies the constraints on each module at the definition site, since it is simply the union of all effects. We're now ready to define the `HandlersContext` for our application: ```haskell handlersContext :: HandlersContext Secp256k1 NameserviceModules EffR CoreEffs handlersContext = HandlersContext { signatureAlgP = Proxy @Secp256k1 , modules = nameserviceModules , compileToCore = compileScopedEff , anteHandler = baseAppAnteHandler } where nameserviceModules :: Modules NameserviceModules EffR nameserviceModules = nameserviceModule :+ tokenModule :+ authModule :+ NilModules ``` Finally we're able to define our application that runs in the `CoreEffs` context defined in the SDK: ```haskell app :: App (Sem CoreEffs) app = makeApp handlersContext ``` </div> </div> </div> </div> </body> </html>
